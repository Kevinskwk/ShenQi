#!/usr/bin/env python3

'''
Node that communicates with Microcontroller sends move piece commands.
Hosts a ROS action server for move_piece
'''

import rospy
import actionlib
from chess_msgs.msg import MovePieceAction, MovePieceResult, MovePieceFeedback
from std_msgs.msg import UInt16MultiArray, Int8MultiArray, ByteMultiArray

class MovePieceServer(object):
    def __init__(self, name):
        self._action_name = name
        # TODO: lookup table for different coordintates
        self.table_x = {}
        self.table_y = {}
        self.sensor_sub = rospy.Subscriber(
            'sensor_data', ByteMultiArray, self.sensor_cb, queue_size=1)
        self.move_pub = rospy.Publisher('movement', UInt16MultiArray, queue_size=1)
        self.done = False
        self._as = actionlib.SimpleActionServer(
            self._action_name,
            MovePieceAction,
            execute_cb=self.execute_cb,
            auto_start = False)
        self._as.start()

    def sensor_cb(self, msg):
        # TODO: verify with the sensor reading
        self.done = True
      
    def execute_cb(self, goal):
        rate = rospy.Rate(5)
        for path in goal.paths:
            for i in range(len(path.data)/2):
                move = UInt16MultiArray()
                move.data = [self.table_x[path.data[2*i]],
                             self.table_y[path.data[2*i+1]], int(i != 0)]
                self.move_pub.publish(move)
                self._as.publish_feedback(MovePieceFeedback(
                    '{}, {}'.format(path.data[2*i], path.data[2*i+1])))
                self.done = False
                while not self.done:
                    rate.sleep()
        # Home after finish
        move = UInt16MultiArray()
        move.data = [0, 0, 2]
        self.move_pub.publish(move)
        self._as.set_succeeded(MovePieceResult(True))

rospy.init_node('move_piece_node', anonymous = True)
move_piece_server = MovePieceServer('move_piece')
rospy.spin()

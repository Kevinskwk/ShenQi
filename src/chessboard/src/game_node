#!/usr/bin/env python3

'''
Node that hosts the chess game and communicates to all the periferal nodes
'''
import enum
import rospy
import actionlib
from Board import Board
# TODO: Might need to import Uint8MultiArray and replace Grid
# TODO: Check what message types are redundant and can be replace with std_msgs
from std_msgs.msg import String
from chess_msgs.msg import Grid, PlayerInfo, UIin, UIout, GameCmd
from chess_msgs.srv import SendCmd, ServerInfo
from chess_msgs.msg import \
    MovePieceAction, MovePieceGoal, MovePieceResult, MovePieceFeedback, \
    QuickMatchAction, QuickMatchGoal, QuickMatchResult, QuickMatchFeedback, \
    WaitCmdAction, WaitCmdGoal, WaitCmdResult, WaitCmdFeedback, \
    WaitReadyAction, WaitReadyGoal, WaitReadyResult, WaitReadyFeedback

W = 9
H = 10

INIT_GRID = [True , True , True , True , True , True , True , True , True ,
             False, False, False, False, False, False, False, False, False,
             False, True , False, False, False, False, False, True , False,
             True , False, True , False, True , False, True , False, True ,
             False, False, False, False, False, False, False, False, False,
             False, False, False, False, False, False, False, False, False,
             True , False, True , False, True , False, True , False, True ,
             False, True , False, False, False, False, False, True , False,
             False, False, False, False, False, False, False, False, False,
             True , True , True , True , True , True , True , True , True ]


class States(enum.Enum):
    HOME = 0
    MODE_SELECT = 1
    QUICKMATCH = 2
    LOBBY_INPUT = 3
    LOBBY_WAIT = 4
    PROMPT_INVITE = 5
    ARRANGE = 6
    WAIT_ARRANGE = 7
    PLAYING = 8
    PROMPT_FORFEIT = 9
    ENDGAME = 10


class Game:

    def __init__(self):
        # Chessboard
        # NOTE: current player is always player 1 in the game
        self.board = Board()
        self.curr_grid = [False] * 90
        self.last_move_grid = [False] * 90
        self.illegal = False
        self.selected = None
        self.debounce = None

        # REMOVE the following line later:
        self.curr_grid = INIT_GRID

        # Metadata
        self.state = States.HOME
        self.info_msg = PlayerInfo()
        self.info_msg.player_id = 'abcd'
        self.lobby_input = ''
        self.opponent = ''

        # ROS publishers
        self.player_info_pub = rospy.Publisher(
            'player_info', PlayerInfo, queue_size=10)
        self.UI_output_pub = rospy.Publisher('UI_output', UIout, queue_size=10)

        # ROS subscribers
        self.sensor_sub = rospy.Subscriber(
            'sensor_data', Grid, self.sensor_cb, queue_size=1)
        self.UI_input_sub = rospy.Subscriber(
            'UI_input', UIin, self.UI_input_cb, queue_size=1)
        # for testing
        self.test_cmd_sub = rospy.Subscriber(
            'test_cmd', String, self.test_cmd_cb, queue_size=1)

        # ROS service clients
        rospy.wait_for_service('send_cmd')
        self.send_cmd_client = rospy.ServiceProxy('send_cmd', SendCmd)
        rospy.wait_for_service('server_info')
        self.server_info_client = rospy.ServiceProxy('server_info', ServerInfo)

        # ROS action clients
        self.wait_cmd_client = actionlib.SimpleActionClient(
            'wait_cmd', WaitCmdAction)
        self.wait_ready_client = actionlib.SimpleActionClient(
            'wait_ready', WaitReadyAction)
        self.move_piece_client = actionlib.SimpleActionClient(
            'move_piece', MovePieceAction)
        self.quick_match_client = actionlib.SimpleActionClient(
            'quick_match', QuickMatchAction)

    # Callback functions
    def sensor_cb(self, msg):
        changes = dict()
        for i in range(90):
            if self.curr_grid[i] != msg[i]:
                changes[i] = msg[i]
        if len(changes == 0):
            if not self.debounce is None:
                self.debounce = None
        else:
            if self.debounce is None:
                self.debounce = msg
            elif self.debounce == msg:  # not a bounce
                self.debounce = None
                self.curr_grid = msg
                self.process_change(changes)

    # for testing
    def test_cmd_cb(self, msg):
        start = (int(msg.data[0]), int(msg.data[1]))
        end = (int(msg.data[2]), int(msg.data[3]))
        self.process_move(start, end, test=True)

    def UI_input_cb(self, msg):
        # input: 1, 2, 3, 4
        input = msg.button
        # FSM
        if self.state == States.HOME:
            self.state = States.MODE_SELECT
            self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.MODE_SELECT:
            # Back
            if input == 1:
                self.state = States.HOME
                self.UI_output_pub.publish(UIout("HOME"))
            # Quickmatch
            elif input == 2:
                self.state = States.QUICKMATCH
                self.UI_output_pub.publish(UIout("QUICKMATCH"))
                goal = QuickMatchGoal(self.id)
                self.quick_match_client.send_goal(
                    goal,
                    transition_cb=self.quick_match_done_cb,
                    feedback_cb=self.quick_match_feedback_cb)
            # Lobby
            elif input == 3:
                self.state = States.LOBBY_INPUT
                self.UI_output_pub.publish(UIout("LOBBY INPUT"))
                self.lobby_input = ''

        elif self.state == States.QUICKMATCH:
            # Back
            if input == 1:
                self.quick_match_client.cancel_all_goals()
                self.state = States.MODE_SELECT
                self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.LOBBY_INPUT:
            if len(self.lobby_input) < 4:
                if input == 1:
                    self.lobby_input.append('a')
                elif input == 2:
                    self.lobby_input.append('b')
                elif input == 3:
                    self.lobby_input.append('c')
                elif input == 4:
                    self.lobby_input.append('d')
            if len(self.lobby_input == 4):
                self.state = States.LOBBY_WAIT
                self.UI_output_pub.publish(UIout("LOBBY WAIT"))
                # TODO: send request match action goal

        elif self.state == States.LOBBY_WAIT:
            # Back
            if input == 1:
                # TODO cancel request match goal
                self.state = States.MODE_SELECT
                self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.PROMPT_INVITE:
            # Accept
            if input == 2:
                # TODO: accept and pair with the requester
                self.state = States.ARRANGE
                self.UI_output_pub.publish(UIout("ARRANGE"))
            # Decline
            elif input == 3:
                self.state = States.MODE_SELECT
                self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.ARRANGE:
            # Confirm
            if input == 4:
                if self.check_arrangement():
                    self.wait_ready_client.send_goal(WaitReadyGoal(
                        self.info_msg.player_id,
                        self.opponent))
                else:
                    self.UI_output_pub.publish(
                        UIout("Arrangement error, try again"))

        elif self.state == States.PLAYING:
            # Forfeit
            if input == 3:
                self.state = States.PROMPT_FORFEIT
                self.UI_output_pub.publish(UIout("PROMPT FORFEIT"))

        elif self.state == States.PROMPT_FORFEIT:
            # Yes
            if input == 2:
                self.board.forfeit(1)
                cmd_msg = GameCmd(self.info_msg.player_id,
                                  self.opponent,
                                  'FFFF',
                                  self.board.moves)
                resp = self.send_cmd_client(cmd_msg)
                # Try again, this should not happen
                while not resp.success:
                    print("Send command failed, trying again (OOPS)")
                    resp = self.send_cmd_client(cmd_msg)

                self.state = States.ENDGAME
                self.UI_output_pub.publish(UIout("ENDGAME"))
                self.UI_output_pub.publish(UIout("YOU FORFEIT!"))

            # No
            elif input == 3:
                self.state = States.PLAYING
                self.UI_output_pub.publish(UIout("PLAYING"))

        elif self.state == States.ENDGAME:
            # Quit
            if input == 1 or input == 3:
                self.state = States.HOME
                self.UI_output_pub.publish(UIout("HOME"))
            # Rematch
            if input == 2:
                # TODO: send rematch action goal and wait for response
                self.UI_output_pub.publish(UIout("REMATCH"))

        self.info_msg.mode = self.state
        self.player_info_pub.publish(self.info_msg)

    # WaitCmd action
    def wait_cmd_feedback_cb(self, feedback):
        self.UI_output_pub.publish(UIout(
            "Waiting for opponent to move...{}".format(feedback.wait_time)))

    def wait_cmd_done_cb(self, state, result):
        if state == actionlib.SimpleClientGoalState.SUCCEEDED and \
           result.opponent != 'timeout':
            # Forfeit case
            if result.move == 'FFFF':
                self.board.forfeit(2)
                self.state = States.ENDGAME
                self.UI_output_pub.publish(UIout("ENDGAME"))
                self.UI_output_pub.publish(UIout("OPPONENT FORFEIT, YOU WON!"))
            else:
                start = (int(result.move[0]), int(result.move[1]))
                end = (int(result.move[2]), int(result.move[3]))
                if not self.board.check_legal(start, end):
                    # Should not happen
                    self.UI_output_pub.publish(UIout("RECEIVED ILLEGAL CMD"))
                # TODO: Send MovePiece action goal
                self.board.move(start, end)
                # Check winning
                if self.board.get_winner != -1:
                    self.state = States.ENDGAME
                    self.UI_output_pub.publish(UIout("ENDGAME"))
                    if self.board.get_winner == 2:
                        self.UI_output_pub.publish(UIout("YOU LOSE!"))
                    elif self.board.get_winner == 0:
                        self.UI_output_pub.publish(UIout("DRAW!"))
        else:
            self.state = States.HOME
            self.UI_output_pub.publish(UIout("Timeout waiting for opponent"))
            # TODO: handle the timeout on the other side
            self.UI_output_pub.publish(UIout("HOME"))

    # WaitReady action
    def wait_ready_feedback_cb(self, feedback):
        self.UI_output_pub.publish(UIout(
            "Waiting for opponent to arrange...{}".format(feedback.wait_time)))

    def wait_ready_done_cb(self, state, result):
        if state == actionlib.SimpleClientGoalState.SUCCEEDED:
            self.state = States.PLAYING
            self.UI_output_pub.publish(UIout("PLAYING"))
            if result.first:
                self.board.reset(1)
            else:
                self.board.reset(2)
        else:
            self.state = States.HOME
            self.UI_output_pub.publish(UIout("Timeout waiting for opponent"))
            # TODO: handle the timeout on the other side
            self.UI_output_pub.publish(UIout("HOME"))

    # MovePiece action
    def move_piece_feedback_cb(self, feedback):
        self.UI_output_pub.publish(UIout(
            "Current move: {}".format(feedback.current_move)))

    def move_piece_done_cb(self, state, result):
        self.moving = False

    # QuickMatch action
    def quick_match_feedback_cb(self, feedback):
        self.UI_output_pub.publish(UIout(
            "Matching opponent...{}".format(feedback.wait_time)))

    def quick_match_done_cb(self, state, result):
        if state == actionlib.SimpleClientGoalState.SUCCEEDED and \
           result.opponent != 'timeout':
            self.opponent = result.opponent
            rospy.log_info("Matched with: {}".format(self.opponent))
            self.state = States.ARRANGE
            self.UI_output_pub.publish(UIout("ARRANGE"))
        else:
            rospy.log_info("Failed to find an opponent")
            self.state = States.MODE_SELECT
            self.UI_output_pub.publish(UIout("MODE SELECT"))

    # Other functions
    def process_change(self, changes):
        # recovery from illegal move
        if self.illegal:
            if self.curr_grid == self.last_move_grid:
                self.illegal = False
            return

        # ignore during auto moving and not during PLAYING or PROMPT_FORFEIT
        if self.moving or \
            (self.state != States.PLAYING and
             self.state != States.PROMPT_FORFEIT):
            return

        # auto cancel forfeit if player tries to move
        if self.state == States.PROMPT_FORFEIT:
            self.state = States.PLAYING
            self.UI_output_pub.publish(UIout("PLAYING"))

        if self.board.turn != 1:
            self.illegal = True
            self.UI_output_pub.publish(
                UIout("Illegal Move! Please return the piece!"))
        else:
            # get only one change (multiple also not expected)
            key = next(iter(changes))

            # taking up a piece
            if (self.selected is None) and not changes[key]:
                self.selected = key

            # putting down a piece
            elif (self.selected is not None) and changes[key]:
                start = (self.selected % W, self.selected // W)
                end = (key % W, key // W)
                self.process_move(start, end)

    def process_move(self, start, end, test=False):
        if not self.board.check_legal(start, end):
            if not test:
                self.illegal = True
            self.UI_output_pub.publish(
                UIout("Illegal Move! Please return the piece!"))
        else:
            self.board.move(start, end)
            cmd = str(start[0]) + str(start[1]) + \
                str(end[0]) + str(end[1])
            cmd_msg = GameCmd(self.info_msg.player_id,
                                self.opponent,
                                cmd,
                                self.board.moves)
            resp = self.send_cmd_client(cmd_msg)
            # Try again, should not happen
            while not resp.success:
                print("Send command failed, trying again (OOPS)")
                resp = self.send_cmd_client(cmd_msg)
            # Check winning
            if self.board.get_winner == -1:
                self.wait_cmd_client.send_goal(WaitCmdGoal(
                    self.info_msg.player_id,
                    self.opponent,
                    self.board.moves))
            else:
                self.state = States.ENDGAME
                self.UI_output_pub.publish(UIout("ENDGAME"))
                if self.board.get_winner == 1:
                    self.UI_output_pub.publish(UIout("YOU WIN!"))
                elif self.board.get_winner == 0:
                    self.UI_output_pub.publish(UIout("DRAW!"))

    def check_arrangement(self):
        if self.curr_grid == INIT_GRID:
            self.last_move_grid = INIT_GRID
            return True
        else:
            return False


rospy.init_node('game_node', anonymous=True)
game = Game()
rospy.spin()

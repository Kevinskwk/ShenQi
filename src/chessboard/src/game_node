#!/usr/bin/env python3

'''
Node that hosts the chess game and communicates to all the periferal nodes
'''
import enum
import rospy
import actionlib
from Board import Board
from chess_msgs.msg import Grid, PlayerInfo, UIin, UIout, GameCmd
from chess_msgs.srv import SendCmd, ServerInfo
from chess_msgs.msg import \
    MovePieceAction, MovePieceGoal, MovePieceResult, MovePieceFeedback, \
    QuickMatchAction, QuickMatchGoal, QuickMatchResult, QuickMatchFeedback, \
    WaitCmdAction, WaitCmdGoal, WaitCmdResult, WaitCmdFeedback

W = 9
H = 10

INIT_GRID = [True , True , True , True , True , True , True , True , True ,
             False, False, False, False, False, False, False, False, False,
             False, True , False, False, False, False, False, True , False,
             True , False, True , False, True , False, True , False, True ,
             False, False, False, False, False, False, False, False, False,
             False, False, False, False, False, False, False, False, False,
             True , False, True , False, True , False, True , False, True ,
             False, True , False, False, False, False, False, True , False,
             False, False, False, False, False, False, False, False, False,
             True , True , True , True , True , True , True , True , True ]

class States(enum.Enum):
    HOME = 0
    MODE_SELECT = 1
    QUICKMATCH = 2
    LOBBY_INPUT = 3
    LOBBY_WAIT = 4
    PROMPT_INVITE = 5
    ARRANGE = 6
    WAIT_ARRANGE = 7
    PLAYING = 8
    PROMPT_FORFEIT = 9
    ENDGAME = 10

class Game:

    def __init__(self):
        # Chessboard
        self.board = Board()
        self.curr_grid = [False] * 90
        self.last_move_grid = [False] * 90
        self.illegal = False
        self.selected = None

        ### REMOVE the following line later:
        self.curr_grid = INIT_GRID

        # Metadata
        self.state = States.HOME
        self.info_msg = PlayerInfo()
        self.info_msg.player_id = 'abcd'
        self.lobby_input = ''
        self.opponent = ''

        # ROS publishers
        self.player_info_pub = rospy.Publisher('player_info', PlayerInfo, queue_size=10)
        self.UI_output_pub = rospy.Publisher('UI_output', UIout, queue_size=10)

        # ROS subscribers
        self.sensor_sub = rospy.Subscriber('sensor_data', Grid, self.sensor_cb, queue_size=1)
        self.UI_input_sub = rospy.Subscriber('UI_input', UIin, self.UI_input_cb, queue_size=1)

        # ROS service clients
        rospy.wait_for_service('send_cmd')
        self.send_cmd_client = rospy.ServiceProxy('send_cmd', SendCmd)
        rospy.wait_for_service('server_info')
        self.server_info_client = rospy.ServiceProxy('server_info', ServerInfo)

        # ROS action clients
        self.wait_cmd_client = actionlib.SimpleActionClient('wait_cmd', WaitCmdAction)
        self.move_piece_client = actionlib.SimpleActionClient('move_piece', MovePieceAction)
        self.quick_match_client = actionlib.SimpleActionClient('quick_match', QuickMatchAction)

    # Callback functions
    def sensor_cb(self, msg):
        changes = dict()
        for i in range(90):
            if self.curr_grid[i] != msg[i]:
                changes[i] = msg[i]
        if len(changes > 0):
            self.curr_grid = msg
            # recovery from illegal move
            if self.illegal:
                if msg == self.last_move_grid:
                    self.illegal = False
                return
            # ignore during auto moving and not during PLAYING
            if self.moving or self.state != States.PLAYING:
                return

            if self.board.turn != 1:
                self.illegal = True
                self.UI_output_pub.publish(UIout("Illegal Move! Please return the piece!"))
            else:
                # get only one change (multiple also not expected)
                key = next(iter(changes))

                # taking up a piece
                if (self.selected is None) and not changes[key]:
                    self.selected = key

                # putting down a piece
                elif (self.selected is not None) and changes[key]:
                    start = (self.selected % W, self.selected // W)
                    end = (key % W, key // W)
                    
                    if not self.board.check_legal(start, end):
                        self.illegal = True
                        self.UI_output_pub.publish(UIout("Illegal Move! Please return the piece!"))
                    else:
                        self.board.move(start, end)
                        cmd = str(start[0]) + str(start[1]) + str(end[0]) + str(end[1])
                        cmd_msg = GameCmd(self.info_msg.player_id,
                                          self.opponent,
                                          cmd,
                                          self.board.moves)
                        resp = self.send_cmd_client(cmd_msg)
                        if resp.success:
                            self.wait_cmd_client.send_goal(WaitCmdGoal(
                                self.info_msg.player_id,
                                self.opponent,
                                self.board.moves))

    def UI_input_cb(self, msg):
        # input: 1, 2, 3, 4
        input = msg.button
        # FSM
        if self.state == States.HOME:
            self.state = States.MODE_SELECT
            self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.MODE_SELECT:
            # Back
            if input == 1:
                self.state = States.HOME
                self.UI_output_pub.publish(UIout("HOME"))
            # Quickmatch
            elif input == 2:
                self.state = States.QUICKMATCH
                self.UI_output_pub.publish(UIout("QUICKMATCH"))
                goal = QuickMatchGoal(self.id)
                self.quick_match_client.send_goal( \
                    goal, \
                    transition_cb=self.quick_match_done_cb, \
                    feedback_cb=self.quick_match_feedback_cb)
            # Lobby
            elif input == 3:
                self.state = States.LOBBY_INPUT
                self.UI_output_pub.publish(UIout("LOBBY INPUT"))
                self.lobby_input = ''

        elif self.state == States.QUICKMATCH:
            # Back
            if input == 1:
                self.quick_match_client.cancel_all_goals()
                self.state = States.MODE_SELECT
                self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.LOBBY_INPUT:
            if len(self.lobby_input) < 4:
                if input == 1:
                    self.lobby_input.append('a')
                elif input == 2:
                    self.lobby_input.append('b')
                elif input == 3:
                    self.lobby_input.append('c')
                elif input == 4:
                    self.lobby_input.append('d')
            if len(self.lobby_input == 4):
                self.state = States.LOBBY_WAIT
                self.UI_output_pub.publish(UIout("LOBBY WAIT"))
                # TODO: send request match action goal

        elif self.state == States.LOBBY_WAIT:
            # Back
            if input == 1:
                # TODO cancel request match goal
                self.state = States.MODE_SELECT
                self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.PROMPT_INVITE:
            # Accept
            if input == 2:
                # TODO: accept and pair with the requester
                self.state = States.ARRANGE
                self.UI_output_pub.publish(UIout("ARRANGE"))
            # Decline
            elif input == 3:
                self.state = States.MODE_SELECT
                self.UI_output_pub.publish(UIout("MODE SELECT"))

        elif self.state == States.ARRANGE:
            # Confirm
            if input == 4:
                if self.check_arrangement():
                    # TODO: send action goal to wait for opponent. Continuing
                    # Should be in the action result callback
                    self.state = States.PLAYING
                    self.UI_output_pub.publish(UIout("PLAYING"))
                else:
                    self.UI_output_pub.publish(UIout("Arrangement error, try again"))

        elif self.state == States.PLAYING:
            # Forfeit
            if input == 3:
                self.state = States.PROMPT_FORFEIT
                self.UI_output_pub.publish(UIout("PROMPT FORFEIT"))

        elif self.state == States.PROMPT_FORFEIT:
            # Yes
            if input == 2:
                # TODO: send forfeit command
                self.state = States.ENDGAME
                self.UI_output_pub.publish(UIout("ENDGAME"))
            # No
            elif input == 3:
                self.state = States.PLAYING
                self.UI_output_pub.publish(UIout("PLAYING"))

        elif self.state == States.ENDGAME:
            # Quit
            if input == 1 or input == 3:
                self.state = States.HOME
                self.UI_output_pub.publish(UIout("HOME"))
            # Rematch
            if input == 2:
                # TODO: send rematch action goal and wait for response
                self.UI_output_pub.publish(UIout("REMATCH"))

        self.info_msg.mode = self.state
        self.player_info_pub.publish(self.info_msg)

    def wait_cmd_feedback_cb(self, feedback):
        self.UI_output_pub.publish(UIout(
            "Waiting for opponent...{}".format(feedback.wait_time)))

    def wait_cmd_done_cb(self, state, result):
        pass

    def move_piece_feedback_cb(self, feedback):
        self.UI_output_pub.publish(UIout(
            "Current move: {}".format(feedback.current_move)))

    def move_piece_done_cb(self, state, result):
        self.moving = False

    def quick_match_feedback_cb(self, feedback):
        self.UI_output_pub.publish(UIout(
            "Matching opponent...{}".format(feedback.wait_time)))

    def quick_match_done_cb(self, state, result):
        if state == actionlib.SimpleClientGoalState.SUCCEEDED and \
           result.opponent != 'timeout':
            self.opponent = result.opponent
            rospy.log_info("Matched with: {}".format(self.opponent))
            self.state = States.ARRANGE
            self.UI_output_pub.publish(UIout("ARRANGE"))
        else:
            rospy.log_info("Failed to find an opponent")
            self.state = States.MODE_SELECT
            self.UI_output_pub.publish(UIout("MODE SELECT"))
        
    def check_arrangement(self):
        if self.curr_grid == INIT_GRID:
            self.last_move_grid = INIT_GRID
            return True
        else:
            return False

rospy.init_node('game_node', anonymous = True)
game = Game()
rospy.spin()

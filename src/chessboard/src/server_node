#!/usr/bin/env python3

'''
Node that connects to Firebase and hosts multiple service/action servers
'''

import rospy
import actionlib
from chess_msgs.msg import PlayerInfo
from chess_msgs.msg import QuickMatchAction, QuickMatchFeedback, QuickMatchResult, \
                           WaitCmdAction, WaitCmdFeedback, WaitCmdResult
from chess_msgs.srv import SendCmd, SendCmdResponse, \
                           ServerInfo, ServerInfoResponse

import pyrebase
from .credential import config

# Firebase stuff
firebase = pyrebase.initialize_app(config)
db = firebase.database()

# ROS action server
class QuickMatchServer(object):
    def __init__(self, name):
        self._action_name = name
        self._as = actionlib.SimpleActionServer(
            self._action_name,
            QuickMatchAction,
            execute_cb=self.execute_cb,
            auto_start=False)
        self._as.start()
      
    def execute_cb(self, goal):
        rate = rospy.Rate(1)
        max_time = 600
        i = 0

        while i < max_time:
            users = db.child('users').get()
            for user in users.each():
                if user.key() == goal.requester:
                    request = user.val().get('request')
                    if not (request is None or request == ''):
                        # someone matching me
                        db.child('users').child(request).update({'request': goal.requester})
                        self._as.set_succeeded(QuickMatchResult(request))
                        return

                elif user.val().get('state') == 2 and \
                     (user.val().get('request') is None or user.val().get('request') == ''):
                    # Find someone looking for a match
                    db.child('users').child(goal.requester).update({'request': user.key()})
                    db.child('users').child(user.key()).update({'request': goal.requester})
                    self._as.set_succeeded(QuickMatchResult(user.key()))
                    return

            self._as.publish_feedback(QuickMatchFeedback(i))
            i += 1
            rate.sleep()

        self._as.set_aborted(QuickMatchResult('timeout'))

class WaitCmdServer(object):
    def __init__(self, name):
        self._action_name = name
        self._as = actionlib.SimpleActionServer(
            self._action_name,
            WaitCmdAction,
            execute_cb=self.execute_cb,
            auto_start=False)
        self._as.start()
      
    def execute_cb(self, goal):
        rate = rospy.Rate(1)
        game_id = min(goal.sender, goal.target) + max(goal.sender, goal.target)
        max_time = 600
        i = 0

        while i < max_time:
            moves = db.child('games').child(game_id).child('moves').get().val()
            if moves is None or len(moves) < goal.step + 1:
                self._as.publish_feedback(WaitCmdFeedback(i))
            else:
                _as.set_succeeded(WaitCmdResult(moves[goal.step]))
                return
            i += 1
            rate.sleep()

        self._as.set_aborted(WaitCmdResult('timeout'))

# ROS subscriber
player_sub = rospy.Subscriber('player_info', PlayerInfo, player_cb, queue_size=1)

# ROS service
send_cmd_srv = rospy.Service('send_cmd', SendCmd, handle_send_cmd)
server_info_srv = rospy.Service('server_info', ServerInfo, handle_server_info)

# callback functions
def player_cb(msg):
    db.child('users').child(msg.player_id).update({'state': msg.mode})

# service handling functions
def handle_send_cmd(req):
    # assert validity of cmd
    if not req.cmd.move.isdecimal or len(req.cmd.move) != 4:
        return SendCmdResponse(False)

    game_id = min(req.cmd.sender, req.cmd.target) + max(req.cmd.sender, req.cmd.target)
    if req.cmd.step == 0:
        db.child('games').child(game_id).child('moves').set({0: req.cmd.move})
    else:
        if len(db.child('games').child(game_id).child('moves').get().val()) != req.cmd.step:
            # skipped move
            return SendCmdResponse(False)
        
        db.child('games').child(game_id).child('moves').update({req.cmd.step: req.cmd.move})
        return SendCmdResponse(True)

def handle_server_info(req):
    pass


rospy.init_node('server_node', anonymous = False)
quick_match_server = QuickMatchServer('quick_match')
wait_cmd_server = WaitCmdServer('wait_cmd')

rospy.spin()
